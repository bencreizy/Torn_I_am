<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.jsdelivr.net https://cdn.skypack.dev; img-src 'self' data:; connect-src 'self' https://unpkg.com https://cdn.jsdelivr.net https://cdn.skypack.dev;">
    <title>The Great Inversion | Neon Monolith</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 12px;
            border-radius: 5px;
            border: 1px solid #ff0000;
            color: #ff0000;
            font-family: monospace;
            pointer-events: all;
            z-index: 10;
            box-shadow: 0 0 15px #ff0000;
        }

        input[type=range] {
            width: 120px;
            accent-color: #ff0000;
            cursor: pointer;
        }

        #error-msg {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            padding: 30px;
            border: 1px solid #ff4444;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.9);
            z-index: 20;
        }
    </style>
</head>

<body>
    <div id="controls">
        <label>NEON FLOW</label><br>
        <input type="range" id="speedSlider" min="1" max="100" value="15">
    </div>
    <div id="error-msg"></div>

    <script type="module">
        // Use multiple CDN fallbacks for reliability
        let THREE, OrbitControls;

        async function loadDependencies() {
            const cdnSources = [
                {
                    three: 'https://unpkg.com/three@0.160.0/build/three.module.js',
                    orbit: 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js'
                },
                {
                    three: 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
                    orbit: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js'
                },
                {
                    three: 'https://cdn.skypack.dev/three@0.136.0',
                    orbit: 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js'
                }
            ];

            for (const cdn of cdnSources) {
                try {
                    const threeModule = await import(cdn.three);
                    THREE = threeModule;
                    const orbitModule = await import(cdn.orbit);
                    OrbitControls = orbitModule.OrbitControls;
                    console.log('Loaded Three.js from:', cdn.three);
                    return true;
                } catch (e) {
                    console.warn('CDN failed:', cdn.three, e.message);
                }
            }
            return false;
        }

        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.textContent = msg;
            el.style.display = 'block';
        }

        // Check WebGL support
        function checkWebGL() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                return !!gl;
            } catch (e) {
                return false;
            }
        }

        async function init() {
            if (!checkWebGL()) {
                showError('WebGL is not supported by your browser. Please use a modern browser.');
                return;
            }

            const loaded = await loadDependencies();
            if (!loaded) {
                showError('Failed to load 3D libraries. Please check your connection and refresh.');
                return;
            }

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls(camera, renderer.domElement);
            camera.position.set(18, 12, 18);
            controls.enableDamping = true;

            const count = 15000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.09,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 1.0
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            let time = 0;
            const speedSlider = document.getElementById('speedSlider');

            function animate() {
                requestAnimationFrame(animate);
                const flowRate = speedSlider.value * 0.0001;
                time += flowRate;
                const pos = geometry.attributes.position.array;
                const cols = geometry.attributes.color.array;

                // The untouched Solo Inversion engine
                const pulse = Math.sin(time * 2) * 0.05 + 1;

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    let progress = (i / count + time * 4) % 1;
                    const spiralStep = (i / count) * Math.PI * 2 * 13;
                    const circleStep = progress * Math.PI * 2;

                    const radius = 7 * pulse;
                    const x = (radius + radius * Math.cos(circleStep)) * Math.cos(spiralStep);
                    const z = (radius + radius * Math.sin(circleStep)) * Math.sin(spiralStep);
                    const y = radius * Math.sin(circleStep);

                    pos[i3] = x;
                    pos[i3 + 1] = y;
                    pos[i3 + 2] = z;

                    const dist = Math.sqrt(x * x + y * y + z * z);
                    const hotZone = Math.pow(1.0 - (dist / 14), 2);

                    // Neon coloring: Red (inverted/outer) ↔ Cyan (non-inverted/inner)
                    // hotZone: 1 = singularity center, 0 = outer edge
                    const t = hotZone;
                    // Red glows brighter at outer edge, cyan glows brighter at singularity
                    const redGlow = 0.5 + 0.5 * (1 - t);    // 0.5–1.0, brightest outer
                    const cyanGlow = 0.5 + 0.5 * t;          // 0.5–1.0, brightest center

                    cols[i3] = (1 - t) * redGlow;         // R: strong red fading inward
                    cols[i3 + 1] = t * cyanGlow * 0.85;       // G: cyan component near center
                    cols[i3 + 2] = t * cyanGlow;              // B: full cyan/blue near center
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                points.rotation.y += 0.001;
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        init().catch(err => {
            console.error('Initialization failed:', err);
            showError('Initialization failed: ' + err.message);
        });
    </script>

    <!-- Source protection -->
    <script>
        (function () {
            // Block right-click context menu
            document.addEventListener('contextmenu', function (e) { e.preventDefault(); return false; });

            // Block dev tools and view-source keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // F12
                if (e.key === 'F12') { e.preventDefault(); return false; }
                // Ctrl+Shift+I / Ctrl+Shift+J / Ctrl+Shift+C (dev tools)
                if (e.ctrlKey && e.shiftKey && ['I', 'i', 'J', 'j', 'C', 'c'].includes(e.key)) { e.preventDefault(); return false; }
                // Ctrl+U (view source)
                if (e.ctrlKey && (e.key === 'u' || e.key === 'U')) { e.preventDefault(); return false; }
                // Ctrl+S (save page)
                if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); return false; }
            });

            // Disable text selection and dragging
            document.addEventListener('selectstart', function (e) {
                if (e.target.tagName !== 'INPUT') e.preventDefault();
            });
            document.addEventListener('dragstart', function (e) { e.preventDefault(); });

            // Detect and warn if dev tools open (debugger timing check)
            var _c = console;
            Object.defineProperty(window, 'console', { get: function () { return _c; }, set: function () { } });

            // Overwrite document.title on blur (tab switching detection is optional)
            // Clear console periodically to deter inspection
            setInterval(function () { _c.clear(); }, 2000);
        })();
    </script>
</body>

</html>